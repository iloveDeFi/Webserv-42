#include "Client.hpp"

Client::Client(int fd, const struct sockaddr_in &address)
    : _socket(fd), _address(address), _request(""), _response() {}

Client::~Client() {}

void Client::readRequest(const std::string &rawData)
{
    _request = HttpRequest(rawData);
}

void Client::processRequest(const _server &serverInfo)
{
    HttpResponse response;
    bool requestHandled = false;
    std::string uri = _request.getURI();
    // TO DO : URI value is good here
    // std::cout << "Requested URI: " << uri << std::endl;
    std::string method = _request.getMethod();

    // Instantiate Logger (logs will be written to "server.log") use cat
    Logger &logger = Logger::getInstance("server.log");

    for (size_t i = 0; i < serverInfo._locations.size(); ++i)
    {
        const HttpConfig::Location &location = serverInfo._locations[i];

        if (uri.find(location.path) == 0)
        {
            if (_request.getMethod() == "GET")
            {
                // std::cout << "------- Processing request - Method: " << method << ", URI: " << uri << std::endl; good here
                GetRequestHandler getHandler(location, serverInfo._root);
                getHandler.handle(_request, response);
                requestHandled = true;
            }
            else if (_request.getMethod() == "POST")
            {
                PostRequestHandler postHandler(location, serverInfo._root);
                postHandler.handle(_request, response);
                requestHandled = true;
            }
            else if (_request.getMethod() == "DELETE")
            {
                DeleteRequestHandler deleteHandler(location, serverInfo._root);
                deleteHandler.handle(_request, response);
                requestHandled = true;
            }
            else
            {
                UnknownRequestHandler unknownHandler(location, serverInfo._root);
                unknownHandler.handle(_request, response);
                requestHandled = true;
            }
            break;
        }
    }

    if (requestHandled)
    {
        int statusCode = response.getStatusCode();
        logger.logRequest(method, uri, statusCode);
        if (statusCode >= 400)
        {
            logger.logError("Request resulted in error: " + to_string(statusCode));
        }
    }
    else
    {
        response.setStatusCode(404);
        response.setBody("404 Not Found");
        response.setHeader("Content-Type", "text/plain");
        response.ensureContentLength();
        logger.logError("404 Not Found for URI: " + uri);
    }

    _response = response;
}

void Client::sendResponse()
{
    std::string response = _response.toString();
    const char *data = response.c_str();
    size_t total = response.size();
    size_t sent = 0;
    ssize_t n;

    while (sent < total)
    {
        n = send(_socket, data + sent, total - sent, 0);
        if (n == -1)
        {
            if (errno == EINTR)
            {
                continue; // Réessayer si l'envoi a été interrompu par un signal
            }
            else
            {
                throw std::runtime_error("Error sending response: " + std::string(strerror(errno)));
            }
        }
        sent += n; // Ajouter le nombre d'octets envoyés avec succès
    }
}

void Client::setHttpRequest(const HttpRequest &request)
{
    _request = request;
}

void Client::setHttpResponse(const HttpResponse &response)
{
    _response = response;
}

HttpRequest &Client::getHttpRequest()
{
    return _request;
}

HttpResponse &Client::getHttpResponse()
{
    return _response;
}

int Client::getClientSocket()
{
    return _socket;
}

std::string Client::getIPaddress()
{
    char *cString = inet_ntoa(_address.sin_addr);
    return std::string(cString);
}

bool Client::isConnected() const
{
    return _socket >= 0;
}

 struct sockaddr_in& Client::getClientAddr()
 {
    return (_address);
 }#include "HttpConfig.hpp"
#include <iostream>
#include <algorithm>
#include <cctype>
#include <set>
#include <sys/stat.h>

//HttpConfig::HttpConfig() {}

HttpConfig::~HttpConfig() {}

HttpConfig::HttpConfig(const std::string& configPath) {
    loadConfigFromFile(configPath);
}

std::vector<HttpConfig::ServerConfig>& HttpConfig::getParsedServers() {
    return parsedServers;
}

void HttpConfig::loadConfigFromFile(const std::string& configPath) {
    configContent = readConfigFile(configPath);
    parseConfigurationFile();
}

std::string HttpConfig::readConfigFile(const std::string& configPath) {
    std::ifstream file(configPath.c_str());
    if (!file.is_open()) {
        throw std::runtime_error("Cannot open configuration file: " + configPath);
    }

    std::stringstream buffer;
    std::string line;
    while (std::getline(file, line)) {
        trimWhitespace(line);
        if (!line.empty() && line[0] != '#') {
            buffer << line << '\n';
        }
    }

    if (file.bad()) {
        throw std::runtime_error("Error reading configuration file: " + configPath);
    }

    return buffer.str();
}

void HttpConfig::parseConfigurationFile() {
    std::istringstream configStream(configContent);
    while (parseServerConfiguration(configStream)) {}
    if (parsedServers.empty()) {
        throw std::runtime_error("No valid server configuration found");
    }
}
bool HttpConfig::parseServerConfiguration(std::istringstream& configStream) {
    ServerConfig serverData;
    std::string configLine, currentSection;
    std::set<std::string> definedAttributes;

    while (std::getline(configStream, configLine)) {
        trimWhitespace(configLine);
        if (configLine.empty() || configLine[0] == '#') {
            continue;
        }

        if (configLine == "- server:") {
            if (!serverData.serverName.empty()) {
                validateServerConfiguration(serverData);
                parsedServers.push_back(serverData);
                serverData = ServerConfig();
                definedAttributes.clear();
                return true;
            }
            continue;
        }

        if (configLine == "error_pages:") {
            currentSection = "errorPages";
        } else if (configLine == "locations:") {
            currentSection = "locations";
            parseLocationConfig(configStream, serverData);
        } else if (currentSection == "errorPages") {
            parseErrorPageConfig(configLine, serverData);
        } else {
            parseServerAttribute(configLine, serverData, definedAttributes);
        }
    }

    if (!serverData.serverName.empty()) {
        validateServerConfiguration(serverData);
        parsedServers.push_back(serverData);
    }

    return false;
}

void HttpConfig::parseLocationConfig(std::istringstream& configStream, ServerConfig& serverData) {
    Location location;
    std::string configLine;
    bool isFirstLocation = true;
    std::set<std::string> locationPaths;

    while (std::getline(configStream, configLine)) {
        trimWhitespace(configLine);
        if (configLine.empty() || configLine[0] == '#') continue;

        if (configLine == "- server:" || configLine.find("server_name:") != std::string::npos) {
            configStream.seekg(-static_cast<int>(configLine.length()) - 1, std::ios::cur); // Revenir en arrière pour que cette ligne soit relue
            break;
        }

        if (configLine.find("- path:") != std::string::npos) {
            if (!isFirstLocation) {
                // Valider la location précédente avant de la stocker
                validateLocation(location, serverData);
                serverData.locations.push_back(location);
            }
            location = Location();
            location.path = configLine.substr(configLine.find(":") + 1);
            trimWhitespace(location.path);
            isFirstLocation = false;
        } else if (!isFirstLocation) {
            // Parser les attributs de la location
            size_t separatorPosition = configLine.find(": ");
            if (separatorPosition != std::string::npos) {
                std::string key = configLine.substr(0, separatorPosition);
                std::string value = configLine.substr(separatorPosition + 2);
                trimWhitespace(key);
                trimWhitespace(value);
                parseLocationAttribute(key, value, location, serverData);
            } else {
                throw std::runtime_error("Invalid location attribute format: " + configLine);
            }
        }
    }

    // Ajouter la dernière location
    if (!location.path.empty()) {
        validateLocation(location, serverData);
        serverData.locations.push_back(location);
    }
}



void HttpConfig::parseServerAttribute(const std::string& attributeLine, ServerConfig& serverData, std::set<std::string>& definedAttributes) {
    size_t separatorPosition = attributeLine.find(": ");
    if (separatorPosition == std::string::npos) {
        throw std::runtime_error("Invalid attribute format: " + attributeLine);
    }

    const std::string attributeKey = attributeLine.substr(0, separatorPosition);
    const std::string attributeValue = attributeLine.substr(separatorPosition + 2);

    if (definedAttributes.find(attributeKey) != definedAttributes.end()) {
        throw std::runtime_error("Duplicate attribute: " + attributeKey);
    }
    definedAttributes.insert(attributeKey);

    if (attributeKey == "server_name") {
        serverData.serverName = attributeValue;
    } else if (attributeKey == "port") {
        serverData.port = parsePortNumber(attributeValue);
    } else if (attributeKey == "client_max_body_size") {
        serverData.clientMaxBodySize = parseBodySizeLimit(attributeValue);
    } else if (attributeKey == "root") {
        serverData.root = attributeValue;
        if (!directoryExists(serverData.root)) {
            throw std::runtime_error("Server root directory does not exist or is not accessible: " + serverData.root);
        }
    } else {
        throw std::runtime_error("Unknown server attribute: " + attributeKey);
    }
}

int HttpConfig::parsePortNumber(const std::string& portString) {
    if (!isAllDigits(portString)) {
        throw std::runtime_error("Port must consist exclusively of numbers");
    }
    int port = std::atoi(portString.c_str());
    if (port <= 0 || port > 65535) {
        throw std::runtime_error("Port number out of valid range (1-65535)");
    }
    if (port < 1024) {
    }
    return port;
}

size_t HttpConfig::parseBodySizeLimit(const std::string& sizeString) {
    size_t multiplier = 1;
    std::string numericPart = sizeString;

    char lastChar = sizeString[sizeString.length() - 1];
    if (lastChar == 'k' || lastChar == 'K') {
        multiplier = 1024;
        numericPart = sizeString.substr(0, sizeString.length() - 1);
    } else if (lastChar == 'm' || lastChar == 'M') {
        multiplier = 1024 * 1024;
        numericPart = sizeString.substr(0, sizeString.length() - 1);
    }

    if (!isAllDigits(numericPart)) {
        throw std::runtime_error("Invalid client_max_body_size format");
    }

    size_t sizeLimit = static_cast<size_t>(std::atol(numericPart.c_str())) * multiplier;
    if (sizeLimit == 0) {
        throw std::runtime_error("client_max_body_size must be greater than 0");
    }
    if (sizeLimit > 1024 * 1024 * 1024) { // 1 GB limit
        throw std::runtime_error("client_max_body_size exceeds maximum allowed (1 GB)");
    }

    return sizeLimit;
}

void HttpConfig::parseErrorPageConfig(const std::string& errorPageLine, ServerConfig& serverData) {
    size_t separatorPosition = errorPageLine.find(": ");
    if (separatorPosition == std::string::npos) {
        throw std::runtime_error("Invalid error_page format: " + errorPageLine);
    }

    std::string errorCodeString = errorPageLine.substr(0, separatorPosition);
    std::string errorPagePath = errorPageLine.substr(separatorPosition + 2);

    if (errorCodeString.empty() || !isAllDigits(errorCodeString)) {
        throw std::runtime_error("Error code must be a valid number: " + errorCodeString);
    }

    int errorCode = std::atoi(errorCodeString.c_str());

    if (errorCode < 400 || errorCode >= 600) {
        throw std::runtime_error("Invalid HTTP error code (must be between 400 and 599): " + errorCodeString);
    }

    if (errorPagePath.empty()) {
        throw std::runtime_error("Error page path cannot be empty for error code: " + errorCodeString);
    }

    if (!fileExists(serverData.root + "/" + errorPagePath)) {
        throw std::runtime_error("Error page file does not exist: " + errorPagePath);
    }

    serverData.errorPages[errorCode] = errorPagePath;
}

/* void HttpConfig::parseLocationConfig(std::istringstream& configStream, ServerConfig& serverData) {
    Location location;
    std::string configLine;
    bool isFirstLocation = true;
    std::set<std::string> locationPaths;


	while (std::getline(configStream, configLine)) {
        trimWhitespace(configLine);
        if (configLine.empty() || configLine[0] == '#') continue;
         

        if (configLine == "- server:" || configLine.find("server_name:") != std::string::npos) {
            configStream.seekg(-static_cast<int>(configLine.length()) - 1, std::ios::cur); // Revenir en arrière pour que cette ligne soit relue
            break;
        }

        if (configLine.find("- path:") != std::string::npos) {
            if (!isFirstLocation) {
                serverData.locations.push_back(location);
            }
            location = Location();
            location.path = configLine.substr(configLine.find(":") + 1);
            trimWhitespace(location.path);
            isFirstLocation = false;
        }
    }

    if (!location.path.empty()) {
        serverData.locations.push_back(location);
    }

} */
void HttpConfig::parseLocationAttribute(const std::string& key, const std::string& value, Location& location, const ServerConfig& serverData) {
    if (key == "methods") {
        std::string methodsValue = value;
        // Vérifier si la valeur commence par '[' et se termine par ']'
        if (!methodsValue.empty() && methodsValue.front() == '[' && methodsValue.back() == ']') {
            // Supprimer les crochets
            methodsValue = methodsValue.substr(1, methodsValue.length() - 2);
        }
        std::vector<std::string> methodsVector = split(methodsValue, ',');
        location.methods.clear();
        for (std::vector<std::string>::iterator it = methodsVector.begin(); it != methodsVector.end(); ++it) {
            std::string method = *it;
            trimWhitespace(method);
            method = toUpperCase(method);
            if (method == "GET" || method == "POST" || method == "DELETE") {
                location.methods.push_back(method);
            } else {
                throw std::runtime_error("Invalid HTTP method: " + method + ". Only GET, POST, and DELETE are allowed.");
            }
        }
        if (location.methods.empty()) {
            throw std::runtime_error("At least one valid HTTP method must be specified.");
        }
    } else if (key == "root") {
        location.root = value;
        if (!directoryExists(location.root)) {
            throw std::runtime_error("Location root directory does not exist or is not accessible: " + location.root);
        }
    } else if (key == "index") {
        location.index = value;
    } else if (key == "autoindex") {
        if (value != "on" && value != "off") {
            throw std::runtime_error("Invalid autoindex value. Must be 'on' or 'off'.");
        }
        location.autoindex = (value == "on");
    } else if (key == "cgi_extensions") {
        location.cgiExtensions = split(value.substr(1, value.length() - 2), ',');
        for (std::vector<std::string>::iterator it = location.cgiExtensions.begin(); it != location.cgiExtensions.end(); ++it) {
            if ((*it)[0] != '.') {
                throw std::runtime_error("CGI extension must start with a dot: " + *it);
            }
        }
    } else if (key == "allow_uploads") {
        if (value != "true" && value != "false") {
            throw std::runtime_error("Invalid allow_uploads value. Must be 'true' or 'false'.");
        }
        location.allowUploads = (value == "true");
    } else if (key == "upload_store") {
        location.uploadStore = value;
        if (!directoryExists(location.uploadStore)) {
            throw std::runtime_error("Upload store directory does not exist or is not accessible: " + location.uploadStore);
        }
    } else if (key == "client_max_body_size") {
        location.clientMaxBodySize = parseBodySizeLimit(value);
        if (location.clientMaxBodySize > serverData.clientMaxBodySize) {
            throw std::runtime_error("Location client_max_body_size exceeds server's limit");
        }
    } else if (key == "handler") {
        location.handler = value;
    } else if (key == "requires_auth") {
        if (value != "true" && value != "false") {
            throw std::runtime_error("Invalid requires_auth value. Must be 'true' or 'false'.");
        }
        location.requiresAuth = (value == "true");
    } else if (key == "content_type") {
        location.contentType = value;
    } else if (key == "include") {
        location.include = value;
	} else if (key == "default_file") {
        location.defaultFile = value;
    } else if (key == "cgi_extensions") {
        location.cgiExtensions = split(value.substr(1, value.length() - 2), ',');
        for (std::vector<std::string>::iterator it = location.cgiExtensions.begin(); it != location.cgiExtensions.end(); ++it) {
            trimWhitespace(*it);
            if ((*it)[0] != '.') {
                throw std::runtime_error("CGI extension must start with a dot: " + *it);
            }
        }
    } else if (key == "cgi_handler") {
        location.cgiHandler = value;
    }
	 else {
        throw std::runtime_error("Unknown location attribute: " + key);
    }
}

void HttpConfig::validateLocation(const Location& location, const ServerConfig& serverData) {

    if (location.path.empty() || location.path[0] != '/') {
        throw std::runtime_error("Invalid location path: " + location.path);
    }

    if (!location.redirect.url.empty()) {
        if (location.redirect.code == 0) {
            throw std::runtime_error("Incomplete redirect configuration for location: " + location.path);
        }
        return;
    }


    if (location.methods.empty()) {
        throw std::runtime_error("No HTTP methods defined for non-redirect location: " + location.path);
    }

    for (std::vector<std::string>::const_iterator it = location.methods.begin(); it != location.methods.end(); ++it) {
        if (*it != "GET" && *it != "POST" && *it != "DELETE") {
            throw std::runtime_error("Invalid HTTP method for location " + location.path + ": " + *it);
        }
    }

    if (location.clientMaxBodySize > serverData.clientMaxBodySize) {
        throw std::runtime_error("Location client_max_body_size exceeds server's limit for location: " + location.path);
    }
}

void HttpConfig::parseRedirect(std::istringstream& configStream, Location& location) {
    std::string redirectLine;
    while (std::getline(configStream, redirectLine)) {
        trimWhitespace(redirectLine);
        if (redirectLine.empty() || redirectLine[0] == '#') continue;
        size_t pos = redirectLine.find(": ");
        if (pos != std::string::npos) {
            std::string redirectKey = redirectLine.substr(0, pos);
            std::string redirectValue = redirectLine.substr(pos + 2);
            if (redirectKey == "url") {
                location.redirect.url = redirectValue;
            } else if (redirectKey == "code") {
                int code = std::atoi(redirectValue.c_str());
                if (code != 301 && code != 302 && code != 303 && code != 307 && code != 308) {
                    throw std::runtime_error("Invalid redirect code: " + redirectValue);
                }
                location.redirect.code = code;
            }
        }
        if (redirectLine.find("code:") != std::string::npos) break;
    }
    if (location.redirect.url.empty() || location.redirect.code == 0) {
        throw std::runtime_error("Incomplete redirect configuration for location: " + location.path);
    }
}

void HttpConfig::validateServerConfiguration(const ServerConfig& serverData) {
    if (serverData.serverName.empty()) {
        throw std::runtime_error("Server name is missing");
    }
    if (serverData.port == 0) {
        throw std::runtime_error("Port is missing or invalid for server: " + serverData.serverName);
    }
    if (serverData.clientMaxBodySize == 0) {
        throw std::runtime_error("Client max body size is missing or invalid for server: " + serverData.serverName);
    }
    if (serverData.locations.empty()) {
        throw std::runtime_error("No locations defined for server: " + serverData.serverName);
    }

    if (serverData.root.empty()) {
        throw std::runtime_error("Server root is empty for server: " + serverData.serverName);
    } else if (!directoryExists(serverData.root)) {
        throw std::runtime_error("Server root directory does not exist or is not accessible: " + serverData.root + " for server: " + serverData.serverName);
    }
}


bool HttpConfig::directoryExists(const std::string& path) {
    struct stat info;
    if (stat(path.c_str(), &info) != 0) {
        return false;
    }
    return (info.st_mode & S_IFDIR) != 0;
}

bool HttpConfig::fileExists(const std::string& path) {
    struct stat info;
    //std::cout << path << std::endl;
    if (stat(path.c_str(), &info) != 0) {
        return false;
    }
    return (info.st_mode & S_IFREG) != 0;
}

std::string HttpConfig::toUpperCase(const std::string& str) {
    std::string result = str;
    for (std::string::iterator it = result.begin(); it != result.end(); ++it) {
        *it = std::toupper(static_cast<unsigned char>(*it));
    }
    return result;
}

void HttpConfig::trimWhitespace(std::string& str) {
    size_t first = str.find_first_not_of(" \t\n\r");
    size_t last = str.find_last_not_of(" \t\n\r");
    if (first != std::string::npos && last != std::string::npos) {
        str = str.substr(first, (last - first + 1));
    } else {
        str.clear();
    }
}

bool HttpConfig::isAllDigits(const std::string& str) {
    for (std::string::const_iterator it = str.begin(); it != str.end(); ++it) {
        if (!std::isdigit(*it)) {
            return false;
        }
    }
    return !str.empty();
}

std::vector<std::string> HttpConfig::split(const std::string& s, char delimiter) {
    std::vector<std::string> tokens;
    std::string token;
    std::istringstream tokenStream(s);
    while (std::getline(tokenStream, token, delimiter)) {
        trimWhitespace(token);
        if (!token.empty()) {
            tokens.push_back(token);
        }
    }
    return tokens;
}

bool HttpConfig::isCgiScript(const Location& location, const std::string& filename) {
    if (location.cgiExtensions.empty()) {
        return false;
    }
    std::string extension = filename.substr(filename.find_last_of(".") + 1);
    return std::find(location.cgiExtensions.begin(), location.cgiExtensions.end(), "." + extension) != location.cgiExtensions.end();
}

bool HttpConfig::shouldListDirectory(const Location& location, const std::string& path) {
    return location.autoindex && directoryExists(path);
}#include "HttpController.hpp"

RequestController::RequestController(const HttpConfig::Location &locationConfig, const std::string &serverRoot)
    : _locationConfig(locationConfig), _deletionInProgress(), _serverRoot(serverRoot)
{
    if (_validMethods.empty())
    {
        _validMethods.insert("GET");
        _validMethods.insert("POST");
        _validMethods.insert("DELETE");
        _validMethods.insert("UNKNOWN");
    }
}

RequestController::RequestController(const RequestController &src)
    : _locationConfig(src._locationConfig), _deletionInProgress(src._deletionInProgress) {}

RequestController &RequestController::operator=(const RequestController &src)
{
    if (this != &src)
    {
        // _locationConfig = src._locationConfig; nope ref constante here
        _deletionInProgress = src._deletionInProgress;
    }
    return *this;
}

RequestController::~RequestController() {}

GetRequestHandler::GetRequestHandler(const HttpConfig::Location &locationConfig, const std::string &serverRoot)
    : RequestController(locationConfig, serverRoot) {}

GetRequestHandler::~GetRequestHandler() {}

void GetRequestHandler::handle(const HttpRequest &req, HttpResponse &res)
{
    handleGetResponse(req, res);
}

PostRequestHandler::PostRequestHandler(const HttpConfig::Location &locationConfig, const std::string &serverRoot)
    : RequestController(locationConfig, serverRoot) {}

PostRequestHandler::~PostRequestHandler() {}

void PostRequestHandler::handle(const HttpRequest &req, HttpResponse &res)
{
    handlePostResponse(req, res);
}

DeleteRequestHandler::DeleteRequestHandler(const HttpConfig::Location &locationConfig, const std::string &serverRoot)
    : RequestController(locationConfig, serverRoot) {}

DeleteRequestHandler::~DeleteRequestHandler() {}

void DeleteRequestHandler::handle(const HttpRequest &req, HttpResponse &res)
{
    handleDeleteResponse(req, res);
}

UnknownRequestHandler::UnknownRequestHandler(const HttpConfig::Location &locationConfig, const std::string &serverRoot)
    : RequestController(locationConfig, serverRoot) {}

UnknownRequestHandler::~UnknownRequestHandler() {}

void UnknownRequestHandler::handle(const HttpRequest &req, HttpResponse &res)
{
    handleUnknownResponse(req, res);
}

bool RequestController::hasReadPermissions(const std::string &filePath)
{
    Logger &logger = Logger::getInstance("server.log");
    logger.log("Checking read permissions for: " + filePath);

    if (access(filePath.c_str(), R_OK) == 0)
    {
        struct stat fileStat;
        if (stat(filePath.c_str(), &fileStat) == 0)
        {
            logger.log("File exists and is accessible.");
            return S_ISREG(fileStat.st_mode);
        }
    }
    logger.log("Access denied or file does not exist.");
    return false;
}

std::string RequestController::loadResource(const std::string &filePath)
{
    std::ifstream file(filePath.c_str(), std::ios::in);
    if (!file.is_open())
    {
        throw std::runtime_error("Unable to open file: " + filePath);
    }
    std::string content;
    std::string line;

    while (std::getline(file, line))
    {
        content += line + "\n";
    }

    if (file.bad())
    {
        throw std::runtime_error("Error reading file: " + filePath);
    }

    file.close();
    return content;
}

bool RequestController::hasPermissionToCreate(const std::string &uri)
{
    std::string path = uri;
    size_t lastSlash = path.find_last_of('/');
    std::string parentDir = (lastSlash != std::string::npos) ? path.substr(0, lastSlash) : ".";

    struct stat dirStat;
    if (stat(parentDir.c_str(), &dirStat) != 0)
    {
        return false;
    }

    return (access(parentDir.c_str(), W_OK) == 0);
}

bool RequestController::hasPermissionToDelete(const std::string &uri) const
{
    (void)uri;
    return std::find(_locationConfig.methods.begin(), _locationConfig.methods.end(), "DELETE") != _locationConfig.methods.end();
}

bool RequestController::isValidHttpMethod(const std::string &method) const
{
    return _validMethods.find(method) != _validMethods.end();
}

bool RequestController::isMethodAllowed(const std::string &method) const
{
    return std::find(_locationConfig.methods.begin(), _locationConfig.methods.end(), method) != _locationConfig.methods.end();
}

bool RequestController::isDirectory(const std::string &path)
{
    struct stat statbuf;
    if (stat(path.c_str(), &statbuf) != 0)
    {
        return false;
    }
    return S_ISDIR(statbuf.st_mode);
}

std::string RequestController::resolveResourcePath(const std::string &uri)
{
    std::string resourcePath = _serverRoot;

    if (resourcePath[resourcePath.length() - 1] != '/')
        resourcePath += '/';

    std::string finalUri = uri;
    if (finalUri[0] == '/')
        finalUri = finalUri.substr(1);

    if (finalUri.empty())
    {
        resourcePath += "index/index.html";
    }
    else
    {
        resourcePath += finalUri;
        if (isDirectory(resourcePath))
        {
            if (resourcePath[resourcePath.length() - 1] != '/')
                resourcePath += '/';
            resourcePath += "index.html";
        }
    }

    return (resourcePath);
}

void RequestController::serveResource(const std::string &resourcePath, HttpResponse &res)
{
    Logger &logger = Logger::getInstance("server.log");

    try
    {
        std::string resourceContent = loadResource(resourcePath);
        res.generate200OK("text/html", resourceContent);
        logger.log("Response Status Code: " + to_string(res.getStatusCode()));
        logger.log("Response Body Length: " + to_string(resourceContent.length()));
        setCorsHeaders(res);
    }
    catch (const std::exception &e)
    {
        logger.log("Error occurred while loading resource: " + std::string(e.what()));
        res.generate500InternalServerError("Internal error 500: " + std::string(e.what()));
    }

    res.ensureContentLength();
    res.logHttpResponse(logger);
}

void RequestController::handleGetResponse(const HttpRequest &req, HttpResponse &res)
{
    Logger &logger = Logger::getInstance("server.log");
    std::string uri = req.getURI();
    logger.log("Received URI: " + uri);

    std::string version = req.getHTTPVersion();
    if (version != "HTTP/1.1" && version != "HTTP/1.0")
    {
        res.generate400BadRequest("Invalid HTTP version");
        logger.log("Invalid HTTP version received: " + version);
        return;
    }

    std::string resourcePath = resolveResourcePath(uri);
    logger.log("Resolved resource path: " + resourcePath);

    if (!hasReadPermissions(resourcePath))
    {
        res.generate403Forbidden("403 Forbidden: Access to the resource is forbidden");
        logger.log("Error: Access to the resource is forbidden for resourcePath: " + resourcePath);
        return;
    }

    serveResource(resourcePath, res);
}

void RequestController::handlePostResponse(const HttpRequest &req, HttpResponse &res)
{
    std::string uri = req.getURI();
    std::string version = req.getHTTPVersion();
    std::string body = req.getBody();

    if (body.empty())
    {
        res.generate400BadRequest("400 error : Bad Request: Empty body or malformed request.");
        return;
    }

    if (!hasPermissionToCreate(uri))
    {
        res.generate403Forbidden("403 Forbidden Error: You do not have permission to create a resource at this location.");
        return;
    }
    try
    {
        res.generate201Created(uri);
    }
    catch (const std::exception &e)
    {
        res.generate500InternalServerError("500 Internal Server Error: An error occurred while processing the request: " + std::string(e.what()));
    }

    res.setHTTPVersion(version);
    res.ensureContentLength();
}

void RequestController::handleDeleteResponse(const HttpRequest &req, HttpResponse &res)
{
    std::string uri = req.getURI();
    std::string version = req.getHTTPVersion();

    if (!hasPermissionToDelete(uri))
    {
        res.generate403Forbidden("403 Forbidden: You do not have permission to delete this resource.");
        return;
    }
    std::string resourcePath = _locationConfig.root + uri;
    if (remove(resourcePath.c_str()) != 0)
    {
        res.generate404NotFound("404 Not Found: Resource not found: " + uri);
        return;
    }

    res.generate204NoContent("204 No Content: Delete success");
    res.setHTTPVersion(version);
}

void RequestController::handleUnknownResponse(const HttpRequest &req, HttpResponse &res)
{
    std::string version = req.getHTTPVersion();
    std::string method = req.getMethod();

    if (method.empty())
    {
        res.generate400BadRequest("400 Bad Request: Method cannot be empty.");
        return;
    }

    res.generate405MethodNotAllowed("405 Method Not Allowed: The method " + method + " is not allowed.");
    res.setHTTPVersion(version);
}

void RequestController::setCorsHeaders(HttpResponse &res)
{
    res.setHeader("Access-Control-Allow-Origin", "*");                  // Permet toutes les origines
    res.setHeader("Access-Control-Allow-Methods", "GET, POST, DELETE"); // Méthodes autorisées
    res.setHeader("Access-Control-Allow-Headers", "Content-Type");      // En-têtes autorisés
}#include "../includes/HttpMessage.hpp"

// Constructors and Destructor
HttpMessage::HttpMessage() {
    _version = "HTTP/1.1";
    _headers = std::map<std::string, std::string>();
    _body = "";
}

HttpMessage::~HttpMessage() {}

// Getters
std::string HttpMessage::getHTTPVersion() const {
    return _version;
}

std::map<std::string, std::string> HttpMessage::getHeaders() const {
    return _headers;
}

std::string HttpMessage::getHeader(const std::string& name) const {
    std::map<std::string, std::string>::const_iterator it = _headers.find(name);
    if (it != _headers.end()) {
        return it->second;
    } else {
        return "";
    }
}

std::string HttpMessage::getBody() const {
    return _body;
}

// Setters
void HttpMessage::setHTTPVersion(const std::string& version) {
    _version = version;
}

void HttpMessage::setHeaders(const std::map<std::string, std::string>& headers) {
    _headers = headers;
}

void HttpMessage::setHeader(const std::string& name, const std::string& value) {
    _headers[name] = value;
}

void HttpMessage::setBody(const std::string& body) {
    _body = body;
}

// Utility Functions
std::string HttpMessage::safe_substr(const std::string& str, size_t start, size_t length) const {
    if (start >= str.size()) throw std::out_of_range("Substring extraction failed: start index out of bounds.");
    if (start + length > str.size()) throw std::out_of_range("Substring extraction failed: length out of bounds.");
    return str.substr(start, length);
}

std::string HttpMessage::trim(const std::string& str) const {
    size_t first = str.find_first_not_of(" \t");
    if (first == std::string::npos) return "";
    size_t last = str.find_last_not_of(" \t");
    return safe_substr(str, first, last - first + 1);
}
#include "HttpRequest.hpp"

std::string HttpRequest::trim(const std::string &str)
{
    size_t first = str.find_first_not_of(' ');
    if (std::string::npos == first)
    {
        return "";
    }
    size_t last = str.find_last_not_of(' ');
    return str.substr(first, (last - first + 1));
}

HttpRequest::HttpRequest(const std::string &rawData)
    : _method(""), _uri(""), _version("HTTP/1.1"), _headers(), _body(""), _queryParameters(""), _allowedMethods(initMethods())
{

    // rawData is good here!
    std::cout << "Raw request data: " << rawData << std::endl;

    std::istringstream requestStream(rawData);
    std::string requestLine;

    if (std::getline(requestStream, requestLine))
    {
        std::istringstream lineStream(requestLine);
        lineStream >> _method >> _uri >> _version;

        if (_method.empty() || _uri.empty() || _version.empty())
        {
            throw std::runtime_error("Invalid request line");
        }

        size_t queryPos = _uri.find('?');
        if (queryPos != std::string::npos)
        {
            _queryParameters = _uri.substr(queryPos + 1);
            _uri = _uri.substr(0, queryPos);
        }
    }

    std::string headerLine;
    while (std::getline(requestStream, headerLine) && !headerLine.empty())
    {
        size_t colonPos = headerLine.find(':');
        if (colonPos != std::string::npos)
        {
            std::string headerName = trim(headerLine.substr(0, colonPos));
            std::string headerValue = trim(headerLine.substr(colonPos + 1));
            _headers[headerName] = headerValue;
        }
    }

    std::map<std::string, std::string>::iterator contentLengthIt = _headers.find("Content-Length");
    if (contentLengthIt != _headers.end())
    {
        int contentLength = atoi(contentLengthIt->second.c_str());
        if (contentLength > 0)
        {
            char *bodyData = new char[contentLength + 1];
            requestStream.read(bodyData, contentLength);
            bodyData[contentLength] = '\0';
            _body = std::string(bodyData);
            delete[] bodyData;
        }
    }
}

HttpRequest::~HttpRequest() {}

HttpRequest::HttpRequest(const HttpRequest &src)
    : _method(src._method), _uri(src._uri), _version(src._version), _headers(src._headers), _body(src._body), _queryParameters(src._queryParameters), _allowedMethods(src._allowedMethods) {}

HttpRequest &HttpRequest::operator=(const HttpRequest &src)
{
    if (this != &src)
    {
        _method = src._method;
        _uri = src._uri;
        _version = src._version;
        _headers = src._headers;
        _body = src._body;
        _queryParameters = src._queryParameters;
        _allowedMethods = src._allowedMethods;
    }
    return *this;
}

std::string HttpRequest::getMethod() const { return _method; }
std::string HttpRequest::getURI() const { return _uri; }
std::string HttpRequest::getHTTPVersion() const { return _version; }

std::map<std::string, std::string> HttpRequest::getHeaders() const { return _headers; }

std::string HttpRequest::getHeader(const std::string &name) const
{
    std::map<std::string, std::string>::const_iterator it = _headers.find(name);
    if (it != _headers.end())
    {
        return it->second;
    }
    return "";
}

std::string HttpRequest::getBody() const { return _body; }
std::string HttpRequest::getQueryParameters() const { return _queryParameters; }

bool HttpRequest::isChunked() const { return false; }

std::set<std::string> HttpRequest::initMethods()
{
    std::set<std::string> methods;
    methods.insert("GET");
    methods.insert("POST");
    methods.insert("DELETE");
    return methods;
}

bool HttpRequest::isMethodAllowed(const std::string &method) const
{
    return _allowedMethods.find(method) != _allowedMethods.end();
}

bool HttpRequest::isSupportedContentType(const std::string &contentType) const
{
    std::set<std::string> supportedTypes;
    supportedTypes.insert("application/json");
    supportedTypes.insert("text/html");
    supportedTypes.insert("text/plain");

    return supportedTypes.find(contentType) != supportedTypes.end();
}

std::ostream &operator<<(std::ostream &os, const HttpRequest &req)
{
    os << "Method: " << req.getMethod() << "\n";
    os << "URI: " << req.getURI() << "\n";
    os << "Version: " << req.getHTTPVersion() << "\n";
    os << "Headers: \n";
    std::map<std::string, std::string> headers = req.getHeaders();
    for (std::map<std::string, std::string>::const_iterator it = headers.begin(); it != headers.end(); ++it)
    {
        os << it->first << ": " << it->second << "\n";
    }
    os << "Body: " << req.getBody() << "\n";
    os << "Query Parameters: " << req.getQueryParameters() << "\n";
    os << "Chunked: " << (req.isChunked() ? "Yes" : "No") << "\n";
    return os;
}

/* void HttpRequest::requestController(HttpResponse &response)
{
    HttpConfig::Location locationConfig;
    GetRequestHandler getHandler(locationConfig);
    PostRequestHandler postHandler(locationConfig);
    DeleteRequestHandler deleteHandler(locationConfig);
    UnknownRequestHandler unknownHandler(locationConfig);

    std::map<std::string, RequestController *> handlerMap;
    handlerMap["GET"] = &getHandler;
    handlerMap["POST"] = &postHandler;
    handlerMap["DELETE"] = &deleteHandler;

    std::string method = getMethod();
    std::map<std::string, RequestController *>::iterator it = handlerMap.find(method);

    if (it != handlerMap.end())
    {
        RequestController *handler = it->second;
        handler->handle(*this, response);
    }
    else
    {
        unknownHandler.handle(*this, response);
    }
} */

void HttpRequest::logHttpRequest(Logger &logger)
{
    std::ostringstream logMessage;

    logMessage << "HTTP Request:\n";
    logMessage << "Method: " << _method << "\n";
    logMessage << "URI: " << _uri << "\n";
    logMessage << "HTTP Version: " << _version << "\n";

    logMessage << "Headers:\n";
    for (std::map<std::string, std::string>::const_iterator it = _headers.begin(); it != _headers.end(); ++it)
    {
        logMessage << it->first << ": " << it->second << "\n";
    }

    logMessage << "Body: " << _body << "\n";
    logMessage << "Query Parameters: " << _queryParameters << "\n";

    logger.log(logMessage.str());
}#include "HttpResponse.hpp"

HttpResponse::HttpResponse()
    : _httpVersion("HTTP/1.1"), _statusCode(200), _reasonMessage("OK"), _headers(), _body(""), _isChunked(false) {}

HttpResponse::~HttpResponse() {}

HttpResponse::HttpResponse(const HttpResponse &src)
    : _httpVersion(src._httpVersion), _statusCode(src._statusCode), _reasonMessage(src._reasonMessage), _headers(src._headers), _body(src._body), _isChunked(src._isChunked) {}

HttpResponse &HttpResponse::operator=(const HttpResponse &src)
{
    if (this != &src)
    {
        _httpVersion = src._httpVersion;
        _statusCode = src._statusCode;
        _reasonMessage = src._reasonMessage;
        _headers = src._headers;
        _body = src._body;
        _isChunked = src._isChunked;
    }
    return *this;
}

void HttpResponse::generate200OK(const std::string &contentType, const std::string &bodyContent)
{
    setStatusCode(200);
    setReasonMessage("OK");

    setHeader("Content-Type", contentType);

    // TO DO : fix ensure function reset content-length to 0
    // ensureContentLength();
    setHeader("Content-Length", to_string(bodyContent.size()));
    setHeader("Cache-Control", "no-store");

    setBody(bodyContent);
}

void HttpResponse::generate201Created(const std::string &location)
{
    setStatusCode(201);
    setReasonMessage("Created");
    setHeader("Location", location);
    setHeader("Content-Type", "text/plain");
    std::string body = "201 Created : Resource successfully created at " + location;
    setBody(body);
    setHeader("Content-Length", to_string(body.size()));
}

void HttpResponse::generate202Accepted(const std::string &deletionInfo)
{
    setStatusCode(202);
    setReasonMessage("Accepted");
    setHeader("Content-Type", "text/plain");
    std::string body = "202 Accepted: The deletion request was accepted and is being processed.\n" + deletionInfo;
    setBody(body);
    setHeader("Content-Length", to_string(body.size()));
}

void HttpResponse::generate204NoContent(const std::string &errorMessage)
{
    setStatusCode(204);
    setReasonMessage("No Content");
    setHeader("Content-Type", "text/plain");
    setHeader("Content-Length", "0");
    setBody("");
    (void)errorMessage;
}

void HttpResponse::generate400BadRequest(const std::string &errorMessage)
{
    setStatusCode(400);
    setReasonMessage("Bad Request");
    setHeader("Content-Type", "text/plain");
    std::string body = "400 Bad Request: " + errorMessage;
    setBody(body);
    setHeader("Content-Length", to_string(body.size()));
}

void HttpResponse::generate403Forbidden(const std::string &errorMessage)
{
    setStatusCode(403);
    setReasonMessage("Forbidden");
    setHeader("Content-Type", "text/plain");
    // std::string body = "403 Forbidden: You don't have permission to access this resource.";
    std::string body = errorMessage;
    setBody(body);
    setHeader("Content-Length", to_string(body.size()));
}

void HttpResponse::generate404NotFound(const std::string &errorMessage)
{
    setStatusCode(404);
    setReasonMessage("Not Found");
    setHeader("Content-Type", "text/plain");
    std::string body = "404 Not Found : " + errorMessage;
    setBody(body);
    setHeader("Content-Length", to_string(body.size()));
}

void HttpResponse::generate405MethodNotAllowed(const std::string &allowedMethods)
{
    setStatusCode(405);
    setReasonMessage("Method Not Allowed");
    setHeader("Content-Type", "text/plain");
    std::string body = "405 Method Not Allowed: The method used is not allowed for this resource.\nAllowed Methods: " + allowedMethods;
    setBody(body);
    setHeader("Content-Length", to_string(body.size()));
    setHeader("Allow", allowedMethods);
}

void HttpResponse::generate409Conflict(const std::string &conflictInfo)
{
    setStatusCode(409);
    setReasonMessage("Conflict");
    setHeader("Content-Type", "text/plain");
    std::string body = "409 Conflict: The request could not be completed due to a conflict with the current state of the resource.\n" + conflictInfo;
    setBody(body);
    setHeader("Content-Length", to_string(body.size()));
}

void HttpResponse::generate500InternalServerError(const std::string &errorMessage)
{
    setStatusCode(500);
    setReasonMessage("Internal Server Error");
    setHeader("Content-Type", "text/plain");
    // TO DO : safety check no expose important info in errorMessage
    std::string body = "500 Internal Server Error: The server encountered an error. " + errorMessage;
    setBody(body);
    setHeader("Content-Length", to_string(body.size()));
}

void HttpResponse::generate501NotImplemented(const std::string &errorMessage)
{
    setStatusCode(501);
    setReasonMessage("Not Implemented");
    setHeader("Content-Type", "text/plain");
    std::string body = "501 Not Implemented: The server does not recognize the HTTP method used. " + errorMessage;
    setBody(body);
    setHeader("Content-Length", to_string(body.size()));
}

std::string HttpResponse::getFullResponse()
{
    std::string response;

    response += _httpVersion + " " + to_string(_statusCode) + " " + _reasonMessage + "\r\n";

    for (std::map<std::string, std::string>::const_iterator it = _headers.begin(); it != _headers.end(); ++it)
    {
        response += it->first + ": " + it->second + "\r\n";
    }

    response += "\r\n";

    response += _body;

    return response;
}

void HttpResponse::setHTTPVersion(const std::string &httpVersion) { _httpVersion = httpVersion; }
void HttpResponse::setStatusCode(int statusCode) { _statusCode = statusCode; }
void HttpResponse::setReasonMessage(const std::string &reasonMessage) { _reasonMessage = reasonMessage; }
void HttpResponse::setHeader(const std::string &name, const std::string &value) { _headers[name] = value; }
void HttpResponse::setHeaders(const std::map<std::string, std::string> &headers) { _headers = headers; }
void HttpResponse::setBody(const std::string &body) { _body = body; }
void HttpResponse::setIsChunked(bool isChunked) { _isChunked = isChunked; }

int HttpResponse::getStatusCode() const
{
    return _statusCode;
}

std::string HttpResponse::normalizeHeader(const std::string &header)
{
    std::string normalized = header;
    for (std::string::size_type i = 0; i < header.size(); ++i)
    {
        normalized[i] = std::tolower(header[i]);
    }
    return normalized;
}

void HttpResponse::ensureContentLength()
{
    if (_headers.find("Content-Length") == _headers.end())
    {
        _headers["Content-Length"] = to_string(_body.size());
    }
}

std::string HttpResponse::toString()
{
    std::string response = _httpVersion + " " + to_string(_statusCode) + " " + _reasonMessage + "\r\n";

    for (std::map<std::string, std::string>::const_iterator it = _headers.begin(); it != _headers.end(); ++it)
    {
        response += it->first + ": " + it->second + "\r\n";
    }

    response += "\r\n" + _body;
    return response;
}

std::string HttpResponse::generate404Error(const std::string &uri)
{
    std::string errorPage = "<html><body><h1>404 Not Found</h1>";
    errorPage += "<p>The requested resource " + uri + " was not found on this server.</p></body></html>";

    return "HTTP/1.1 404 Not Found\r\nContent-Type: text/html\r\nContent-Length: " + to_string(errorPage.size()) + "\r\n\r\n" + errorPage;
}

std::string HttpResponse::generateRedirection(const std::string &newUri)
{
    return "HTTP/1.1 302 Found\r\nLocation: " + newUri + "\r\n\r\n";
}

std::ostream &HttpResponse::print(std::ostream &os) const
{
    os << "--- RESPONSE LINE INFOS: ---" << std::endl;
    os << "httpVersion is: " << _httpVersion << " Status code is: " << _statusCode << " Reason Message is: " << _reasonMessage << "\n\n";

    os << "--- HEADER INFOS: ---" << std::endl;
    os << "Headers are: " << std::endl;
    for (std::map<std::string, std::string>::const_iterator it = _headers.begin(); it != _headers.end(); ++it)
    {
        os << it->first << ": " << it->second << std::endl;
    }

    os << "--- BODY INFOS: ---" << std::endl;
    os << "Content-Length: " << _body.size() << "\n\n";
    os << "Body is: " << _body << "\n";
    os << "Body chunked: " << _isChunked << "\n";
    return os;
}

void HttpResponse::logHttpResponse(Logger &logger)
{
    std::ostringstream logMessage;

    logMessage << "HTTP Response:\n";
    logMessage << "HTTP Version: " << _httpVersion << "\n";
    logMessage << "Status Code: " << _statusCode << "\n";
    logMessage << "Reason Message: " << _reasonMessage << "\n";

    logMessage << "Headers:\n";
    for (std::map<std::string, std::string>::const_iterator it = _headers.begin(); it != _headers.end(); ++it)
    {
        logMessage << it->first << ": " << it->second << "\n";
    }

    logMessage << "Body: " << _body << "\n";

    logger.log(logMessage.str());
}#include "Logger.hpp"

Logger *Logger::_instance = nullptr;

Logger::Logger(const std::string &filename)
{
    _logFile.open(filename.c_str(), std::ios::app);
    if (!_logFile.is_open())
    {
        std::cerr << "Failed to open log file: " << filename << std::endl;
    }
}

Logger::~Logger()
{
    if (_logFile.is_open())
    {
        _logFile.close();
    }
}

Logger &Logger::getInstance(const std::string &filename)
{
    if (_instance == nullptr)
    {
        _instance = new Logger(filename);
    }
    return *_instance;
}

std::string Logger::getCurrentTime()
{
    std::time_t now = std::time(0);
    char buf[80];
    std::strftime(buf, sizeof(buf), "%Y-%m-%d %X", std::localtime(&now));
    return std::string(buf);
}

void Logger::log(const std::string &message)
{
    if (_logFile.is_open())
    {
        _logFile << "[" << getCurrentTime() << "] " << message << std::endl;
    }
}

void Logger::logError(const std::string &errorMessage)
{
    log("ERROR: " + errorMessage);
}

void Logger::logRequest(const std::string &method, const std::string &uri, int statusCode)
{
    log("REQUEST: Method=" + method + ", URI=" + uri + ", Status Code=" + to_string(statusCode));
}#include "MngmtServers.hpp"

// fichier fdConfig imaginé sans retour à la ligne à part pour différents serveurs:
// server1: root:/html index:index.html,index.htm error:404,not_found.html
// error:500,error.html listing:true name:mywebserv listen:8888
// Limitations:client_max_body_size 8M; ??
// server2:root:/html index:index.html etc.

// note il faut qu'on trouve un moyen pour pouvoir passer
// la valeur de la taille des fichiers ()
//  • k or K: Kilobytes
//  • m or M: Megabytes
//  • g or G: Gigabytes

// constructeur du gestionnaire de serveurs
// il va découper le fichier en ligne (chacune représentant un serveur)
// et ajouter un serveur au veteur de _servers
ManagementServer::ManagementServer(HttpConfig &config)
{
	std::string line;

	std::vector<HttpConfig::ServerConfig>::iterator it = config.getParsedServers().begin();

	while (it != config.getParsedServers().end())
	{
		addNewServer(*it);
		it++;
	}
}

ManagementServer::~ManagementServer()
{
	for (std::vector<_server>::iterator it = _servers.begin();
		 it != _servers.end(); it++)
	{
		close(it->_serverSocket->getFdSocket());
		delete it->_serverSocket;
		// delete la map location ?
	}
}

// suite du constructeur
//  cette fonction remplie en gros toute la struct du serveur
//  et active l'écoute passive du port
//  En détail:
// parse la ligne entre key et value pour récupérer les infos
// de config importantes
//  crée une Socket (classe), la définie comme non-bloquante
//  la lie avec le port d'écoute (bind) et écoute les requests (listen)
#include <sstream>

void ManagementServer::addNewServer(HttpConfig::ServerConfig server)
{
	_server newServer;
	socklen_t addrLen;

	try
	{
		newServer._name = server.serverName;
		newServer._port = server.port;
		newServer._maxSize = server.clientMaxBodySize;
		newServer._errorPages = server.errorPages;
		newServer._locations = server.locations;
		newServer._root = server.root;

		newServer._serverSocket = new Socket(AF_INET, SOCK_STREAM, 0, newServer._port, INADDR_ANY);
		addrLen = sizeof(newServer._serverSocket->getAddress());

		setNonBlocking(newServer._serverSocket->getFdSocket());

		try
		{
			newServer._serverSocket->Bind();
		}
		catch (const std::runtime_error &e)
		{
			std::ostringstream errorMsg;
			if (errno == EACCES)
			{
				errorMsg << "Permission denied. You may need root privileges to bind to port " << newServer._port;
				throw std::runtime_error(errorMsg.str());
			}
			else if (errno == EADDRINUSE)
			{
				errorMsg << "Address already in use. Port " << newServer._port << " may already be occupied.";
				throw std::runtime_error(errorMsg.str());
			}
			else
			{
				throw; // Rethrow the original exception if it's not one of the specific cases we're handling
			}
		}

		newServer._serverSocket->Listen();

		int ip = getsockname(newServer._serverSocket->getFdSocket(),
							 (struct sockaddr *)&newServer._serverSocket->getAddress(),
							 &addrLen);
		if (ip == -1)
		{
			std::string errorStr = "Error getting host IP: ";
			errorStr += strerror(errno);
			throw std::runtime_error(errorStr);
		}

		_servers.push_back(newServer);
		_servers.back()._ipAddress = ip;
		std::cout << "Server is listening on port " << newServer._port << std::endl;
	}
	catch (const std::exception &e)
	{
		std::cerr << "Failed to set up server on port " << server.port << ": " << e.what() << std::endl;

		// Clean up resources if an error occurred
		if (newServer._serverSocket)
		{
			delete newServer._serverSocket;
		}

		// Optionally, you might want to rethrow the exception or handle it in some other way
		// throw;
	}
}
// La boucle principale d'écoute des différents serveur lancés
// prépare les FD des serveurs et des potentiels clients
// en modifiant la valeur max du nombre d'FD actif
// commence par 4 (1, 2 et 3 étant les fd réservés) + 1 pour
// le fd(socket) du serveur
// select() (similaire à poll) permet de faire le I/O multiplexing
// en récupéreant les fd préalablement préparés
// si des nouvelles connections sont repérées, elles sont
// acceptées puis gérées
void ManagementServer::handleRequest()
{
	fd_set readFds;
	std::vector<Client> clients;
	int maxFd = 0;

	while (true)
	{
		prepareFdSets(readFds, clients, maxFd);

		// Attendre 5 secondes (et 0microscd) pour un événement sur les
		// sockets surveillés avant de retourner.
		// timeout permet de contrôler la fréquence à laquelle
		// le serveur traite les entrées sans être bloqué indéfiniment
		// en attente d'activité
		struct timeval tv = {5, 0};
		int selectRes = select(maxFd + 1, &readFds, NULL, NULL, &tv);
		if (selectRes > 0)
		{
			acceptNewClients(clients, readFds);
			handleActiveClients(readFds, clients);
		}
		else if (selectRes == -1)
			throw std::runtime_error("Select error");
		else if (selectRes == 0)
		{
			std::cout << "Timeout occurred, performing routine checks." << std::endl;
			continue;
		}
		std::cout << "select() returned: " << selectRes << std::endl;
	}
}

// fonction permettant de préparer et initialiser les fd
//  Typically, the fd_set data type is implemented as a bit mask.
// However, we don’t need to know the details, since all manipulation
//  of file descriptor sets is done via four macros:
// FD_ZERO(), FD_SET(), FD_CLR(), and FD_ISSET().
// FD_ZERO() initializes the set pointed to by fdset to be empty.
// FD_SET() adds the file descriptor fd to the set pointed to by fdset.
void ManagementServer::prepareFdSets(fd_set &readFds,
									std::vector<Client> &clients, int &maxFd)
{

	FD_ZERO(&readFds);
	for (size_t i = 0; i < _servers.size(); i++)
	{
		int serverFd = _servers[i]._serverSocket->getFdSocket();
		FD_SET(serverFd, &readFds);
		if (serverFd > maxFd)
			maxFd = serverFd;
		std::cout << "server Maxfd " << maxFd << std::endl;
	}
    for (size_t i = 0; i < clients.size(); ++i)
    {
        int clientFd = clients[i].getClientSocket();
        FD_SET(clientFd, &readFds);
        if (clientFd > maxFd)
            maxFd = clientFd;
    }
}

// Si une connexion est repérée, elle doit être acceptée avant de pourvoir
// être traiter. accept() créé un socket() chez le client,
// afin de pouvoir être non bloquant cette socket aussi doit être en non bloquant
// FD_ISSET() returns true if the file descFD_CLOEXECriptor fd is a
// member of the set pointed to by fdset. (int FD_ISSET(int fd, fd_set *fdset))
void ManagementServer::acceptNewClients(std::vector<Client> &clients, fd_set &readFds)
{
    for (size_t i = 0; i < _servers.size(); i++)
    {
        if (FD_ISSET(_servers[i]._serverSocket->getFdSocket(), &readFds))
        {
            std::cout << "Connection detected on server " << _servers[i]._name << std::endl;
            struct sockaddr_in clientAddr;
            try
            {
                int clientFd = _servers[i]._serverSocket->Accept(clientAddr);
                setNonBlocking(clientFd);
                Client newClient(clientFd, clientAddr);
                clients.push_back(newClient);
                std::cout << "New client connected on server " << _servers[i]._name << ": " << clientFd << std::endl;
            }
            catch (const std::exception &e)
            {
                std::cerr << "Error accepting client connection: " << e.what() << std::endl;
            }
        }
    }
}





// Configure la socket en non bloquant
//  FD_CLOEXEC : Ce flag est utilisé pour indiquer que
// le descripteur de fichier doit être automatiquement fermé
// lors de l'exécution de la fonction exec(),
// qui est utilisée pour lancer une nouvelle image de programme.
// Cela empêche les nouveaux programmes exécutés de hériter ce descripteur de fichier.
//  F_SETFL: est une commande utilisée avec fcntl
// pour définir les flags du descripteur de fichier.
//  Permet la modification dynamique des propriétés de descripteurs de fichiers.
void ManagementServer::setNonBlocking(int fd)
{
    int flags;

    // Set O_NONBLOCK
    if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
        throw std::runtime_error("Failed to get file flags");
    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1)
        throw std::runtime_error("Failed to set non-blocking mode");

    // Set FD_CLOEXEC
    if ((flags = fcntl(fd, F_GETFD)) == -1)
        throw std::runtime_error("Failed to get fd flags");
    if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
        throw std::runtime_error("Failed to set FD_CLOEXEC");
}


// Loop sur tout les fd actifs pour les gérer individuellement
// si une erreur arrive, le client est supprimé des clients actifs
void ManagementServer::handleActiveClients(fd_set &readFds, std::vector<Client> &clients)
{
    for (size_t i = 0; i < clients.size(); ++i)
    {
        int clientFd = clients[i].getClientSocket();
        if (FD_ISSET(clientFd, &readFds))
        {
            try
            {
                handleClient(clients[i]);
            }
            catch (const std::exception &e)
            {
                std::cerr << "Client error: " << e.what() << std::endl;
                FD_CLR(clientFd, &readFds);
                close(clientFd);
                clients.erase(clients.begin() + i);
                --i;
            }
        }
    }
}


void ManagementServer::handleClient(Client &client)
{
    int clientSocket = client.getClientSocket();
    struct sockaddr_in serverAddr;
    socklen_t serverAddrLen = sizeof(serverAddr);

    //détermine sur quel serveur le client est connecté
    if (getsockname(clientSocket, (struct sockaddr *)&serverAddr, &serverAddrLen) == -1)
    {
        throw std::runtime_error("Error getting server socket information: " + std::string(strerror(errno)));
    }

    int serverPort = ntohs(serverAddr.sin_port);

    //trouver la conf du serveur correspondant à ce port
    _server currentServer;
    bool serverFound = false;
    for (std::vector<_server>::iterator it = _servers.begin(); it != _servers.end(); ++it)
    {
        if (it->_port == serverPort)
        {
            currentServer = *it;
            serverFound = true;
            break;
        }
    }
    if (!serverFound)
    {
        throw std::runtime_error("No server found for port " + std::to_string(serverPort));
    }

    // Lire la requête du client
    std::string rawData = readRawData(clientSocket);
    if (rawData.empty())
    {
        // Si aucune donnée n'a été lue, le client a peut-être fermé la connexion
        throw std::runtime_error("No data received from client.");
    }
	// TO DO : delete?
	client.readRequest(rawData); // parser renvoyé à Alex
	// il ajoute a client sont attribut _request;

	// TO CHECK : yes rawData values are GOOD here
	// std::string rawData = readRawData(clientSocket);
	// client.readRequest(rawData);
	// std::cout << "BEFORE PROCESS : Raw request data: " << rawData << std::endl;

	client.processRequest(currentServer); // gestion de la requete par Baptiste
	// il ajoute a client sont attribut _response;
	client.sendResponse();
}



std::string ManagementServer::readRawData(int clientSocket)
{
    const size_t buffer_size = 1024;
    char buffer[buffer_size];
    std::string requestData;
    ssize_t bytesReceived;

    while (true)
    {
        bytesReceived = recv(clientSocket, buffer, buffer_size - 1, 0);
        if (bytesReceived > 0)
        {
            buffer[bytesReceived] = '\0';
            requestData.append(buffer, bytesReceived);
            if (requestData.find("\r\n\r\n") != std::string::npos)
                break; // Fin des en-têtes
        }
        else if (bytesReceived == 0)
        {
            // Le client a fermé la connexion
            break;
        }
        else
        {
            if (errno == EAGAIN || errno == EWOULDBLOCK)
            {
                // Pas de données disponibles pour le moment, réessayer plus tard
                continue;
            }
            else
            {
                // Une erreur réelle s'est produite
                throw std::runtime_error("Error reading from socket: " + std::string(strerror(errno)));
            }
        }
    }

    return requestData;
}


int ManagementServer::getPort(std::vector<_server>::iterator it)
{
	return (it->_port);
}

int ManagementServer::getSize(std::vector<_server>::iterator it)
{
	return (it->_maxSize);
}

/* _server& ManagementServer::\
getServerInfo(std::vector<_server>::iterator it)
{
	return (*it);
}  */

void ManagementServer::setIpAddress(std::vector<_server>::iterator it, int ip)
{
	it->_ipAddress = ip;
}

#include "Socket.hpp"

Socket::Socket(int domain, int service, int protocol, int port, u_long interface)
{
	std::cout << "port in constructor socket " << port << std::endl;
	_fdSocket = socket(domain, service, protocol);
	if (_fdSocket < 0)
		throw std::runtime_error("Error creating socket.");
	
	_address.sin_family = domain;
	_address.sin_addr.s_addr = interface;
	_address.sin_port = htons(port);

	_len = sizeof(_address);
}

/* Socket::Socket(const Socket &other)
:_fdSocket(other._fdSocket), _address(other._address), _len(other._len)
{}
Socket& Socket::operator=(const Socket &other)
{
	if (this != &other)
	{
		_fdSocket = other._fdSocket;
		_address = other._address;
		_len = other._len;
	}
	return (*this);
} */

Socket::~Socket()
{
	//if (is_open(_fdSocket))
		close(_fdSocket);
}

void Socket::Bind()
{
	if (bind(_fdSocket, (struct sockaddr*)&_address, _len) < 0)
		throw std::runtime_error("Error binding socket.");
	std::cout << "Binding complete on port " << ntohs(_address.sin_port) << std::endl;
}

void Socket::Listen()
{
	if (listen(_fdSocket, MAX_CONNECTIONS) < 0)
		throw std::runtime_error("Error listening socket.");
	std::cout << "Listening complete" << std::endl;
}

int Socket::Accept(struct sockaddr_in &clientAddr)
{
    socklen_t clientLen = sizeof(clientAddr);
    int clientSocket = accept(_fdSocket, (struct sockaddr*)&clientAddr, &clientLen);
    if (clientSocket < 0)
        throw std::runtime_error("Error accepting socket.");
	_clientAddr = clientAddr;
    return clientSocket;
}


ssize_t Socket::Send(int client_socket, const char* buffer, size_t buffer_length, int flags)
{
	ssize_t tmp = send(client_socket, buffer, buffer_length, flags);
	if (tmp < 0)
		throw std::runtime_error("Error sending socket.");
	return (tmp);
}

ssize_t Socket::Receive(int client_socket, char* buffer, size_t buffer_length, int flags)
{
	ssize_t tmp = recv(client_socket, buffer, buffer_length, flags);
	if (tmp < 0)
		throw std::runtime_error("Error receiving socket.");
	return (tmp);
}

int Socket::getFdSocket()
{
	return(_fdSocket);
}
struct sockaddr_in &Socket::getAddress()
{
	return(this->_address);
}
socklen_t Socket::getLen()
{
	return(_len);
}



